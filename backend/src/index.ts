import express, { Request, Response } from 'express'; // FIX 1: Import Request and Response from express
import { MongoClient, Collection, WithId, Document, FindOneAndUpdateOptions } from 'mongodb'; // FIX 2: Better type imports

const app = express();
const port = 3000;

// FIX 3: Add express.json() middleware to parse request bodies
app.use(express.json());

// --- Interfaces ---

// FIX 4: Use string | ObjectId for _id in Item if it's meant to be an actual item document
// However, based on usage, we'll keep it as 'number' for simplicity with the custom counter,
// but add a generic Document type to Collection to satisfy strict TypeScript rules
interface Item {
    _id: number; // Item ID (generated by a counter)
    name: string; // Count in the cart or stock quantity in the item collection
}

interface Cart {
    _id: number; // Cart ID (generated by a counter)
    items: Array<ItemInCart>; // FIX 5: Use a specific interface for items in the cart
}

interface ItemInCart {
    itemId: number; // The _id of the item being referenced
    count: number; // The quantity of this item in the cart
    info: string;
}


let allItems: Collection<Item>;
let carts: Collection<Cart>;
let countersCollection: Collection<{ _id: string, sequence_value: number }>;

// --- MongoDB Connection ---

async function connectToMongo() {
  // FIX 6: Use 'localhost' instead of '127.0.0.1' for better compatibility in some environments
  const url = "mongodb://localhost:27017"; 
  const client = new MongoClient(url);

  try {
    await client.connect();
    console.log('Successfully connected to MongoDB!');
    const db = client.db("hlm");
    allItems = db.collection<Item>("items");
    carts = db.collection<Cart>("carts");
    countersCollection = db.collection<{ _id: string, sequence_value: number }>('counters');
  } catch (error) {
    console.error("Failed to connect to MongoDB", error);
    process.exit(1);
  }
}

// --- Sequence Generator ---

async function getNextSequenceValue(sequenceName: string): Promise<number> {
    // FIX 7: Use the correct types for findOneAndUpdate options
    const options: FindOneAndUpdateOptions = {
        returnDocument: 'after', 
        upsert: true,
    };
    
    // FIX 8: findOneAndUpdate returns an object with a 'value' property.
    const sequenceDocument = await countersCollection.findOneAndUpdate(
        { _id: sequenceName },
        { $inc: { sequence_value: 1 } },
        options
    );

    if (!sequenceDocument) return 0;
    
    // FIX 9: Check the value property of the result object
    if (sequenceDocument) {
        return sequenceDocument.sequence_value;
    }
    
    throw new Error(`Could not retrieve sequence value for ${sequenceName}`); 
}

// --- Helper Function ---

// FIX 10: Corrected interface for Item ID lookup
async function getItem(itemID: number): Promise<WithId<Item> | null> {
    return allItems.findOne({_id: itemID});
}

app.get('/get-cart', async (req: Request, res: Response) => {
    const id = await getNextSequenceValue("carts");
    carts.insertOne({_id:id, items:Array<ItemInCart>()});
    res.status(201).send(id);
});

app.post('/add-to-cart', async (req: Request<{}, {}, { itemID: number, itemCount: number, cartId: number }>, res: Response) => {
    // Destructure properties from the parsed request body
    const { itemID, itemCount, cartId } = req.body;

    // FIX 12: Correct type checking for numeric values
    if (typeof itemID !== 'number' || itemID < 0 || 
        typeof itemCount !== 'number' || itemCount < 0 || 
        typeof cartId !== 'number' || cartId < 0) {
        
        console.log("Incorrect or missing item count, item ID, or cart ID.");
        // FIX 13: Must send a response back to the client
        return res.status(400).json({ error: "Invalid input: itemID, itemCount, and cartId must be positive numbers." });
    }

    try {
        // 1. Check if the item actually exists in the 'item' collection
        const existingItem = await getItem(itemID);
        if (!existingItem) {    
            console.log(`Item with ID ${itemID} not found.`);
            return res.status(404).json({ error: `Item with ID ${itemID} not found.` });
        }

        // 2. Find the cart
        const cart = await carts.findOne({ _id: cartId });
        if (!cart) {
            console.log(`Cart with ID ${cartId} not found.`);
            return res.status(404).json({ error: `Cart with ID ${cartId} not found.` });
        }

        // 3. Check if the item is already in the cart
        const existingCartItemIndex = cart.items.findIndex(item => item.itemId === itemID);

        let updateResult;

        if (existingCartItemIndex > -1) {
            const field = `items.${existingCartItemIndex}.count`;
            updateResult = await carts.updateOne(
                { _id: cartId, "items.itemId": itemID },
                { $inc: { [field]: itemCount } }
            );
        } else {
            const newItemInCart: ItemInCart = { itemId: itemID, count: itemCount, info: "" };
            updateResult = await carts.updateOne(
                { _id: cartId },
                { $push: { items: newItemInCart } }
            );
        }
        
        if (updateResult.modifiedCount === 1 || updateResult.upsertedCount === 1) {
            res.status(200).json({ message: 'Item successfully added/updated in cart', cartId: cartId });
        } else {
            res.status(500).json({ error: 'Failed to update cart document.' });
        }

    } catch (error) {
        console.error("Error in /add-to-cart:", error);
        res.status(500).json({ error: 'Internal server error during cart update.' });
    }
});


connectToMongo().then(() => {
    app.listen(port, () => {
      console.log(`Server is running at http://localhost:${port}`);
    });
});